<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Home - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Breakpoint.html">Breakpoint</a></li><li><a href="GDBError.html">GDBError</a></li><li><a href="Frame.html">Frame</a></li><li><a href="ThreadGroup.html">ThreadGroup</a></li><li><a href="GDB.html">GDB</a><ul class='methods'><li data-type='method'><a href="GDB.html#init">init</a></li><li data-type='method'><a href="GDB.html#set">set</a></li><li data-type='method'><a href="GDB.html#attachOnFork">attachOnFork</a></li><li data-type='method'><a href="GDB.html#enableAsync">enableAsync</a></li><li data-type='method'><a href="GDB.html#attach">attach</a></li><li data-type='method'><a href="GDB.html#detach">detach</a></li><li data-type='method'><a href="GDB.html#interrupt">interrupt</a></li><li data-type='method'><a href="GDB.html#threads">threads</a></li><li data-type='method'><a href="GDB.html#currentThread">currentThread</a></li><li data-type='method'><a href="GDB.html#selectThread">selectThread</a></li><li data-type='method'><a href="GDB.html#threadGroups">threadGroups</a></li><li data-type='method'><a href="GDB.html#currentThreadGroup">currentThreadGroup</a></li><li data-type='method'><a href="GDB.html#selectThreadGroup">selectThreadGroup</a></li><li data-type='method'><a href="GDB.html#addBreak">addBreak</a></li><li data-type='method'><a href="GDB.html#removeBreak">removeBreak</a></li><li data-type='method'><a href="GDB.html#stepIn">stepIn</a></li><li data-type='method'><a href="GDB.html#stepOut">stepOut</a></li><li data-type='method'><a href="GDB.html#next">next</a></li><li data-type='method'><a href="GDB.html#run">run</a></li><li data-type='method'><a href="GDB.html#proceed">proceed</a></li><li data-type='method'><a href="GDB.html#context">context</a></li><li data-type='method'><a href="GDB.html#callstack">callstack</a></li><li data-type='method'><a href="GDB.html#sourceFiles">sourceFiles</a></li><li data-type='method'><a href="GDB.html#evaluate">evaluate</a></li><li data-type='method'><a href="GDB.html#exit">exit</a></li><li data-type='method'><a href="GDB.html#execPy">execPy</a></li><li data-type='method'><a href="GDB.html#execCLI">execCLI</a></li><li data-type='method'><a href="GDB.html#execCMD">execCMD</a></li><li data-type='method'><a href="GDB.html#execMI">execMI</a></li></ul></li><li><a href="Thread.html">Thread</a></li><li><a href="Variable.html">Variable</a></li></ul><h3>Events</h3><ul><li><a href="GDB.html#event:notify">notify</a></li><li><a href="GDB.html#event:status">status</a></li><li><a href="GDB.html#event:exec">exec</a></li><li><a href="GDB.html#event:stopped">stopped</a></li><li><a href="GDB.html#event:running">running</a></li><li><a href="GDB.html#event:thread-created">thread-created</a></li><li><a href="GDB.html#event:thread-exited">thread-exited</a></li><li><a href="GDB.html#event:thread-group-started">thread-group-started</a></li><li><a href="GDB.html#event:thread-group-exited">thread-group-exited</a></li><li><a href="GDB.html#event:new-objfile">new-objfile</a></li></ul>
</nav>

<div id="main">
    

    



    









    


    <section class="readme">
        <article><h1>gdb-js <a href="https://travis-ci.org/baygeldin/gdb-js"><img src="https://travis-ci.org/baygeldin/gdb-js.svg?branch=master" alt="Build Status"></a></h1><p>Seamless GDB wrapper for Node.js (&gt;= 0.12) and the browser.<br>It can be used to build different kinds of frontends for GDB.</p>
<h2>Documentation</h2><p><a href="https://baygeldin.github.io/gdb-js">Documentation is availabe here</a>.<br>Reading the sources of tests is also useful.</p>
<h2>Features</h2><ul>
<li>Support of multithreaded targets.</li>
<li>All methods return Promises.</li>
<li>All MI &amp; CLI commands are supported.</li>
<li>Support of custom Python scripts execution.</li>
<li>Support of multiple targets.</li>
</ul>
<h2>Considerations</h2><ul>
<li>GDB &gt;= 7.3 is required.</li>
<li>GDB should support Python.</li>
<li>GDB should be used in MI mode (i.e. <code>gdb -i=mi</code>).</li>
<li>Although it's possible to use <strong>gdb-js</strong> in the <code>all-stop</code> mode, it makes much more sense for a frontend to work with the <code>non-stop</code> mode (together with <code>target-async</code>). So, it's recommended that <code>enableAsync</code> method should be called.</li>
<li>Execution of all CLI commands is possible only after calling <code>init</code> method which defines some custom supportive commands in GDB. However, you can load them (<code>scripts</code> folder in the project repository) manually with <code>.gdbinit</code> for example.</li>
<li><strong>gdb-js</strong> is a seamless wrapper. It means that it doesn't have any assumptions about your goals and doesn't do anything behind the scenes. So, if something is going wrong it's probably a problem with your GDB usage (i.e. the same problem can be reproduced within a bare console).</li>
<li><strong>gdb-js</strong> has a defined API that should be convinient to use. But if it's not enough for you, it also makes it easy to use low-level stuff. You can execute any GDB/MI command with a <code>execMI</code> method and get a parsed JSON representation of the result. You can execute any CLI command of GDB and get a string as a result. You can also listen to events that emit raw records of GDB/MI interface.</li>
<li>It's currently not posible to distingish target output and GDB output correctly. Thus, it's recommended to use <code>--tty</code> option with your GDB.</li>
<li>For browsers it makes sense to make use of utilities that expose process streams (i.e. stdin/stdout/stderr) through WebSockets.</li>
<li>All methods (where it makes sense) accept thread as the last parameter. So, you can step/continue/interrupt/inspect any thread you want.</li>
<li>If you're debugging a target that spawns new processes with <code>fork</code>, just call <code>attachOnFork</code> method and you're done. If not and you still need to debug multiple targets you should attach them manually (see <a href="https://sourceware.org/gdb/onlinedocs/gdb/Forks.html">the official GDB documentation</a>).</li>
<li><strong>gdb-js</strong> needs <code>babel-polyfill</code> to work, or if you're heading to ES6 environment, just <code>regenerator runtime</code>.</li>
</ul>
<h2>Install</h2><pre class="prettyprint source"><code>$ npm install gdb-js</code></pre><h2>Usage</h2><pre class="prettyprint source lang-javascript"><code>import { spawn } from 'child-process'
import { GDB } from 'gdb-js'

let child = spawn('gdb', ['-i=mi', 'main'])
let gdb = new GDB(child)</code></pre><p>Note that the argument shouldn't necesserily be a Node.js child process. It can be
any object that has stdin/stdout/stderr streams. </p>
<h2>Examples</h2><p>General example:</p>
<pre class="prettyprint source lang-javascript"><code>gdb.on('stopped', (data) => {
  if (data.reason === 'breakpoint-hit') {
    console.log(data.breakpoint.id + 'is hit!')
  }
})

await gdb.break('main.c', 'foo')
await gdb.run()</code></pre><p>Multithreading:</p>
<pre class="prettyprint source lang-javascript"><code>await gdb.init()
await gdb.enableAsync()
await gdb.run()
// stop all the threads
await gdb.interrupt()
// get info about threads
let threads = await gdb.threads()
// continue execution of the first thread
await gdb.continue(threads[1])</code></pre><p>Multiple targets:</p>
<pre class="prettyprint source lang-javascript"><code>// Get all available thread groups (i.e. processes)
let { groups } = await gdb.execMI('-list-thread-groups --available')
let bash = groups.find((p) => p.description === 'bash')
// bash.id is just a pid, it can be any other pid
await gdb.attach(bash.id)</code></pre><h2>Extending</h2><p>Although <strong>gdb-js</strong> supports all CLI and MI commands, you may be interested in extending its functionality usging GDB's <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Python-API.html">Python API</a>. It's possible to add new functionality even without forking <strong>gdb-js</strong>. </p>
<h3>Implementation details</h3><p>In order to understand how to extend the functionality, it may be useful to know a little about internals of <strong>gdb-js</strong>. It distinguishes MI and CLI commands. For MI commands the logic is pretty straightforward: every result record of GDB/MI <a href="https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI-Output-Syntax.html">output syntax</a> is parsed, turned to JSON and returned as a result of <code>execMI</code> method. However, it's not possible to do the same for CLI commands since their output is exposed to console stream. What <strong>gdb-js</strong> does is defining custom CLI commands with Python API that are framed into <code>&lt;gdbjs:cmd:[command_name] [JSON] [command_name]:cmd:gdbjs&gt;</code> where <code>[command_name]</code> is the command name obviously and <code>[JSON]</code> is the valid JSON string. This way we can extract results of such commands and return them as a result of <code>execCMD</code> method. One of such commands that <strong>gdb-js</strong> defines is <code>gdbjs-exec</code> CLI command that executes whatever you pass to it and prints <code>&lt;gdbjs:cmd:exec [results] exec:cmd:gdbjs&gt;</code> where <code>[results]</code> is everything that was written to console during the execution of your command (remember that string is a valid JSON). That's how it's possible to get the results of CLI commands with <code>execCLI</code> method. <code>execCLI(cmd)</code> is essentially <code>execCMD('exec ' + cmd)</code>. And <code>execPy(script)</code> is just <code>execCMD('exec python\\n' + escape(script))</code> (we need to escape quotes and other stuff). Also <strong>gdb-js</strong> uses events from Python API and it writes them to console stream as <code>&lt;gdbjs:event:[event_name] [JSON] [event_name]:event:gdbjs&gt;</code> where <code>[event_name]</code> is the name of the event and <code>[JSON]</code> is the contents of the event. All of these internal <strong>gdb-js</strong> messages are stripped from the <code>consoleStream</code> property of this wrapper. It's possible to define your own events and commands and here's how.</p>
<h3>Defining a new command</h3><pre class="prettyprint source lang-python"><code>import gdb


class ThreadIDCommand(BaseCommand):
    &quot;&quot;&quot;Returns the ID of the thread as assigned by OS.&quot;&quot;&quot;

    def __init__(self):
        super(ThreadIDCommand, self).__init__(&quot;thread-id&quot;)

    def action(self, arg, from_tty):
        thread = gdb.selected_thread()
        (pid, lwpid, tid) = thread.ptid
        return { &quot;pid&quot;: pid, &quot;lwpid&quot;: lwpid, &quot;tid&quot;: tid }

threadIDCommand = ThreadIDCommand()</code></pre><pre class="prettyprint source lang-javascript"><code>let script = fs.readFileSync('thread-id.py', { encoding: 'utf8' })

await gdb.execPy(script)

let { pid, lwpid, tid } = await gdb.execCMD('thread-id')</code></pre><p>It's even possible to use defined commands in other defined commands.</p>
<pre class="prettyprint source lang-python"><code>class JustPIDCommand(BaseCommand):
    &quot;&quot;&quot;Returns just the PID of the thread.&quot;&quot;&quot;

    def __init__(self):
        super(JustPIDCommand, self).__init__(&quot;thread-pid&quot;)

    def action(self, arg, from_tty):
        thread = threadIDCommand.action()
        return thread.pid

justPIDCommand = JustPIDCommand()</code></pre><h3>Defining a new CLI command</h3><p>If you want, you can use the bare Python API to define new CLI commands.</p>
<pre class="prettyprint source lang-python"><code>import gdb
import sys


class GreetCommand(gdb.Command):
    &quot;&quot;&quot;My shiny CLI command.&quot;&quot;&quot;

    def __init__(self, name):
        super(BaseCommand, self).__init__(&quot;greet&quot; + name, gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        sys.stdout.write(&quot;Hello {}!&quot;.format(arg))
        sys.stdout.flush()

GreetCommand()</code></pre><pre class="prettyprint source lang-javascript"><code>let script = fs.readFileSync('greet.py', { encoding: 'utf8' })

await gdb.execPy(script)

let greetings = await gdb.execCLI('greet World') // 'Hello World!'</code></pre><h3>Defining a new event</h3><pre class="prettyprint source lang-python"><code>from threading import Timer


def hour_passed_handler(arg_1, arg_2)
    &quot;&quot;&quot;Handle the time.&quot;&quot;&quot;

    base_event_handler(&quot;hour-passed&quot;, &quot;{} {}, pal...&quot;.format(arg_1, arg_2))

Timer(3600.0, hour_passed_handler, (&quot;That's&quot;, &quot;sad&quot;)).start()</code></pre><pre class="prettyprint source lang-javascript"><code>let script = fs.readFileSync('hour.py', { encoding: 'utf8' })

await gdb.execPy(script)

gdb.on('hour-passed', (data) => console.log(data)) // 'That's sad, pal...''</code></pre><h2>Running tests</h2><pre class="prettyprint source"><code>$ npm install
$ npm run docker-pull
$ npm test</code></pre></article>
    </section>






</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Fri Aug 19 2016 12:40:24 GMT+0300 (MSK) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>